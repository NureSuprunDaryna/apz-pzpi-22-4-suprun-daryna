Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії








Практична робота
з дисципліни: “Архітектура програмного забезпечення”
на тему:  «Шаблони проектування. Проксі.»












Виконала ст. гр ПЗПІ-22-4
Супрун Дарина Андріївна


22 березня 2025 р.


Перевірив 
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович










Харків 2025
1 ІСТОРІЯ ЗМІН


Таблиця 1 – Історія змін поточного звіту
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	03.03.2025
	0.1
	Створено документ, додано титульну сторінку та таблицю історії змін
	2
	03.03.2025
	0.1
	Додано розділ 2 ЗАВДАННЯ
	3
	04.03.2025
	0.1 
	Заповнено розділ 2 ЗАВДАННЯ
	4
	05.03.2025
	0.1
	Створення розділів 3 ОПИС ВИКОНАНОЇ РОБОТИ 4 ВИСНОВОК
	5
	06.03.2025
	0.1
	Додано приклад реалізації шаблону «Проксі» мовою C# із коментарями
	6
	07.03.2025
	0.1
	Додано порівняльний аналіз шаблону «Проксі» з декоратором і фасадом
	7
	08.03.2025
	0.1
	Додано список використаної літератури та джерел
	8
	08.03.2025
	0.1
	Завершено остаточне оформлення тексту розділу 3
	9
	22.03.2025
	0.2
	Внесено остаточні правки до звіту
	

________________


2 ЗАВДАННЯ


Завдання на практичне заняття 1 (ПЗ1):
1. Підготувати доповідь на тему: «Шаблон (патерн) проектування ПЗ»
(із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone)
2. Створити та оформити слайди презентації доповіді
3. Створити та опублікувати на YouTube відеозапис доповіді
4. Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5. При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6. Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7. Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
8. Експортувати звіт у файл у простому текстовому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9. Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ


У межах даного завдання було опрацьовано шаблон проектування «Проксі» (Proxy), який належить до групи структурних шаблонів. Основною метою було створення інформативної та технічно вивіреної усної презентації тривалістю 10 хвилин, що пояснює як базові концепції, так і внутрішні механізми реалізації шаблону.
        Під час підготовки презентації було проаналізовано авторитетні джерела, зокрема сайт Refactoring.Guru, книгу «Design Patterns» авторства “Банди чотирьох”, офіційну документацію Microsoft для C#, а також інші тематичні ресурси. Особливу увагу було приділено практичній реалізації шаблону мовою програмування C#, із поясненням механізмів «під капотом» — таких як lazy initialization, інкапсуляція, делегування методів та інтерфейсна взаємозамінність.
        Доповідь структурована у вигляді презентації, що містить логічні блоки: теоретичне введення, мотиваційні приклади з життя, класифікацію типів проксі, приклад коду, порівняння з іншими шаблонами та підсумкові висновки.
        Нижче подано виклад доповіді, яка була підготовлена у формі усної презентації із супроводом візуальних слайдів. Доповідь розкриває ключові аспекти шаблону проектування «Проксі» у послідовності, що відповідає структурі самої презентації. Для кожного слайду подано короткий зміст та пояснення ключових ідей, що озвучувалися під час виступу.
        У процесі розробки програмного забезпечення розробники часто стикаються з повторюваними архітектурними викликами. Наприклад: як ефективно створювати об’єкти? Як забезпечити гнучкість у зміні поведінки? Як організувати стійку взаємодію між частинами програми? Щоб не розв’язувати ці проблеми щоразу з нуля, були створені шаблони проектування — універсальні, багаторазово перевірені рішення типових задач. Їх суть полягає не в конкретному коді, а в структурі — шаблон показує, які класи чи об’єкти потрібні, які між ними мають бути зв’язки, і яку відповідальність несе кожен елемент.
        Всього шаблони поділяються на три основні групи. Породжуючі шаблони допомагають контролювати створення об'єктів. Наприклад, шаблон "Фабрика" дозволяє створювати об’єкти без прив’язки до конкретного класу. Поведінкові шаблони відповідають за взаємодію між об'єктами, наприклад — «Стратегія» або «Ланцюг відповідальностей». А структурні шаблони, до яких належить і «Проксі», працюють з архітектурою системи: вони дозволяють ефективно організовувати зв’язки між класами та об’єктами, приховуючи або інкапсулюючи складність.        
        Саме структурні шаблони часто використовують для того, щоб зробити систему більш гнучкою, модульною і розширюваною. Вони дозволяють додавати нову поведінку або змінювати наявну без зміни коду існуючих компонентів. Шаблон «Проксі» — класичний приклад такого підходу: він створює додатковий об’єкт-посередник між клієнтом і реальною логікою, дозволяючи вбудувати контроль, кешування або іншу функціональність без зміни вихідного класу.
        Шаблон «Проксі» передбачає створення об’єкта, який імітує інтерфейс справжнього об’єкта, але не є ним. Такий об’єкт називається проксі, або представник. Коли клієнт звертається до цього проксі, він навіть не підозрює, що взаємодіє не з реальним об’єктом. Проксі отримує запит і може вирішити: обробити його самостійно, передати далі, затримати, записати в лог або взагалі заблокувати. Це дозволяє втрутитися в процес взаємодії, не змінюючи ні клієнта, ні справжній об’єкт.
        Основна ідея полягає в тому, що проксі реалізує той самий інтерфейс, що й цільовий об’єкт. Це означає, що з точки зору клієнта нічого не змінюється. Але насправді між ним і реальним об’єктом стоїть ще один рівень контролю. Наприклад, якщо створення об’єкта дороге за ресурсами, проксі може створювати його лише за потреби — це називається віртуальний проксі. Або ж якщо доступ до об’єкта має бути захищеним — проксі перевіряє права користувача перед передачею запиту.
        Важливо, що проксі — це не новий функціонал для об’єкта, а обгортка, що додає поведінку навколо. Він може бути абсолютно прозорим або містити складну внутрішню логіку. Саме завдяки цьому шаблон зручно використовувати в ситуаціях, де потрібно розмежувати обов’язки, розвантажити систему або підвищити безпеку. І все це — без модифікацій основного коду.
        Шаблон «Проксі» може здаватися складним, якщо дивитись лише з технічної сторони. Але варто подивитися на нього крізь призму повсякденного життя — і суть стає зрозумілішою. Наприклад, уявімо банківську картку. Коли ви платите за товар, ви не контактуєте з банком напряму і не бачите сам процес транзакції. Ви просто прикладаєте картку — вона відправляє запит, банк його обробляє, і ви отримуєте результат. Картка тут — типовий проксі: вона не містить грошей, але надає до них доступ, захищаючи й спрощуючи взаємодію.
        Ще один приклад — вахтер або охоронець у гуртожитку. Ви хочете потрапити до кімнати, але спершу звертаєтесь до охоронця. Він перевіряє, чи маєте ви право доступу. Якщо так — пропускає, якщо ні — блокує. Вахтер виступає посередником між вами та дверима, до яких ви намагаєтесь дістатись. Це типовий приклад захисного проксі, який регулює доступ відповідно до правил.
        У сфері ІТ аналогом буде проксі-сервер. Коли ви відкриваєте вебсайт, ваш запит може проходити не прямо до сервера сайту, а спершу через проксі. Такий сервер може приховати вашу IP-адресу, кешувати сторінки для швидкого доступу або заборонити певні запити. Ви отримуєте той самий результат, але взаємодієте не з реальним сервером, а з його представником. Це вже приклад смарт-проксі, який оптимізує або змінює поведінку системи.
        Усі ці приклади мають спільну рису: існує реальний об’єкт, але взаємодія з ним відбувається опосередковано, через проксі, який додає додаткову логіку — перевірку, економію, безпеку або інші переваги. Саме ця універсальність і робить шаблон «Проксі» таким популярним і гнучким у застосуванні.
        Шаблон «Проксі» має кілька конкретних реалізацій, і кожна з них вирішує певну архітектурну задачу. Незважаючи на те, що всі вони мають спільну мету — стояти між клієнтом і об’єктом, — способи використання можуть сильно відрізнятися. Давайте розглянемо основні типи проксі окремо, щоб побачити їхню практичну цінність.
        Захисний проксі (Protection Proxy). Цей тип використовується для контролю доступу до об’єкта. Його основне завдання — перевірити, чи має користувач право виконати ту чи іншу дію. Наприклад, в інформаційній системі може бути клас Document, що містить конфіденційні дані. Проксі, який реалізує той самий інтерфейс, перевіряє, чи є в користувача роль "адміністратор" або "редактор". Якщо ні — доступ блокується. Такий підхід дозволяє винести логіку безпеки за межі основного класу, зберігаючи його чистим і орієнтованим лише на бізнес-логіку.
        Віртуальний проксі (Virtual Proxy). Основна мета — економія ресурсів. Ідеальний приклад — відкладене завантаження об’єкта, створення якого є ресурсоємним. Наприклад, зображення великої роздільної здатності або звіт із великою кількістю даних. Реальний об’єкт створюється лише в момент, коли його потрібно показати або обробити. До цього моменту з клієнтською частиною взаємодіє проксі. Це дозволяє значно знизити навантаження на пам’ять і прискорити запуск програми. Такий підхід також добре масштабується, особливо у складних UI-додатках.
        Віддалений проксі (Remote Proxy). Цей тип проксі працює в розподілених системах, коли об’єкти фізично розташовані на різних пристроях або навіть в різних країнах. Клієнт звертається до локального об’єкта-проксі, який пересилає запит по мережі до справжнього об’єкта на віддаленому сервері. Це класична схема в архітектурі клієнт-сервер, зокрема в технологіях типу Java RMI, .NET Remoting або gRPC. Завдяки такому підходу програміст може працювати з об’єктом так, ніби він локальний, не турбуючись про деталі мережевої взаємодії. Це приклад глибокої інкапсуляції складності.
        Смарт-проксі (Smart Proxy). Найбільш гнучкий і універсальний тип. Він додає до взаємодії з об’єктом додаткову поведінку, яка не стосується суті самого об’єкта. Наприклад, це може бути кешування результатів методів, логування дій користувача, перевірка цілісності даних, підрахунок кількості викликів або навіть обмеження частоти доступу. Смарт-проксі зазвичай поєднує функції кількох інших типів і особливо корисний у ситуаціях, коли потрібна аналітика, моніторинг або тонке налаштування поведінки системи без втручання в бізнес-логіку об’єкта.
        Усі ці типи можуть використовуватись окремо або в комбінації, залежно від вимог до архітектури. Їх головна перевага — можливість розділити обов’язки, ізолювавши додаткову логіку від основного об’єкта. Таким чином, шаблон «Проксі» допомагає створювати більш захищені, гнучкі та оптимізовані системи, зберігаючи при цьому чистоту коду.
        Перед вами приклад реалізації шаблону віртуального проксі в C#. Основна мета цього прикладу — відкласти створення важкого об’єкта, яким у нашому випадку є RealImage, до моменту, коли він реально стане потрібен. І це реалізовано за рахунок механізму "лінивої ініціалізації" (lazy initialization).
        У центрі конструкції — інтерфейс IImage, який визначає єдиний метод Display(). Це класичний прийом шаблонів проектування: обидва об’єкти — і проксі, і реальний — реалізують один і той самий інтерфейс, що забезпечує взаємозамінність. Клієнт не знає і не повинен знати, з ким він працює — з проксі чи з реальним об’єктом. Це принцип поліморфізму, реалізований на практиці.
        У класі RealImage цікавий момент — завантаження зображення відбувається вже в конструкторі. Це означає, що сам факт створення об’єкта автоматично вимагає виконання операції LoadFromDisk(). З технічної точки зору, об'єкт одразу споживає ресурси навіть без виклику Display(). Така поведінка може бути критичною для програм, що оперують великою кількістю елементів — скажімо, прев’ю файлів, великих об’єктів, даних із мережі тощо.
        Саме тут вступає в гру ProxyImage. Він інкапсулює створення об’єкта RealImage за допомогою приватного поля _realImage, яке спочатку дорівнює null. Це означає, що в момент створення проксі жодних витрат ресурсів не відбувається. Лише під час виклику Display() спрацьовує перевірка if (_realImage == null) — і тоді, і тільки тоді, створюється об’єкт RealImage. Це класичний шаблон lazy initialization, який є ключовим для оптимізації програм з високим навантаженням.
        Окремо варто звернути увагу, що усі виклики до реального об’єкта відбуваються опосередковано — тобто ми завжди взаємодіємо лише через проксі. Це дозволяє централізовано контролювати доступ, логи, кеш, таймінг, або навіть замінювати об’єкти в режимі реального часу— усе це без зміни клієнтського коду. Така інкапсуляція логіки за інтерфейсом — сильна сторона шаблону.
        Ще один цікавий момент — після першого виклику метод Display() у RealImage викликається напряму, без додаткових перевірок, тобто працює вже як кешований об’єкт, що підвищує швидкодію. У такому вигляді ProxyImage легко масштабується: наприклад, можна ускладнити його логіку, додавши логування, лічильник викликів або механізм очищення з пам’яті.
        Таким чином, цей код демонструє не просто відкладене створення, а потенціал проксі як точки розширення функціональності — без зміни основного класу. Це повністю відповідає принципам SOLID, зокрема — відкритість/закритість (Open/Closed Principle).
        Дуже часто шаблон «Проксі» плутають із Декоратором або Фасадом, оскільки всі вони використовують подібну архітектурну структуру — обгортання одного об’єкта іншим. Але суть, мотивація та поведінка в кожному з них різні, і розуміння цих відмінностей є критично важливим.
        Проксі — це представник або посередник. Він реалізує той самий інтерфейс, що й реальний об’єкт (Subject), і контролює доступ до нього. Це може бути захист, кеш, відкладене створення або мережеве делегування. Ключова риса: проксі не змінює функціональність об’єкта, а лише вирішує коли і чи звертатись до нього. Тобто це — структурна логіка, а не поведінкова.
        Декоратор також реалізує той самий інтерфейс, але його мета — додати нову поведінку або модифікувати вже існуючу. Наприклад, базовий об’єкт повертає рядок, а декоратор додає до нього префікс, логування або змінює формат. Він не обмежує доступ, а розширює функціональність без зміни оригінального класу. Технічно декоратори часто реалізуються рекурсивно (ланцюгом), проксі — зазвичай один.
        Фасад — це шаблон для спрощення складного інтерфейсу. Він не реалізує той самий інтерфейс, що об'єкти всередині, і не виконує логіки перевірки чи контролю. Замість цього фасад створює зручну точку входу до кількох підсистем. Його мета — зменшити складність клієнтського коду, ізолюючи внутрішню реалізацію.
        Усі три шаблони мають структуру "обгортки", але мають різні архітектурні завдання. Проксі — це контроль і інфраструктура. Декоратор — поведінкова модифікація. А фасад — архітектурне спрощення.
        Шаблон «Проксі» — це потужний інструмент, який дозволяє розділити відповідальність у програмі та зробити архітектуру більш гнучкою, контрольованою й економною. Його головна ідея — ввести проміжну ланку між клієнтом і реальним об’єктом, яка може регулювати або доповнювати доступ без втручання в саму бізнес-логіку.
        Проксі ідеально підходить для ситуацій, де об’єкт є ресурсоємним, віддаленим або вимагає безпеки, а також тоді, коли ми хочемо додати логіку перевірки, кешування або аналітики без зміни існуючого коду. Завдяки тому, що проксі реалізує той самий інтерфейс, клієнт взагалі не помічає підміни — і саме це робить його таким зручним у використанні.
        Але варто пам’ятати: шаблон «Проксі» додає ще один шар абстракції. Якщо його застосовувати без необхідності — це може призвести до надлишкової складності та зниження читабельності коду. Тому його використання має бути виправданим архітектурною логікою — наприклад, потребою в контролі, оптимізації чи обмеженні.
        У підсумку, «Проксі» — це не лише шаблон, а архітектурна позиція: коли ти хочеш дати об’єкту не просто силу, а ще й контекст, контроль і межі.


________________


4 ВИСНОВКИ
У межах практичного заняття було повністю реалізовано поставлене завдання: проведено дослідження одного з шаблонів проектування програмного забезпечення — Proxy (Проксі), який належить до структурної групи патернів відповідно до класифікації, запропонованої «Бандою чотирьох» (GoF).
        Було підготовлено усну доповідь тривалістю 10 хвилин, що супроводжується слайдами презентації, у якій послідовно розкрито: загальні поняття шаблонів проектування, суть шаблону Proxy, його класифікацію, практичні приклади з реального життя, технічну реалізацію мовою програмування C#, а також порівняння з подібними шаблонами (Decorator, Facade).
        Код прикладу, що демонструє механізм віртуального проксі з використанням lazy initialization, реалізовано мовою C# і розміщено у репозиторії GitHub. Створено файл README.md, що містить короткий опис виконаної роботи. У репозиторії також присутній звіт у форматі .txt, розміщений у директорії Pract1, а також піддиректорія з усім програмним кодом, відповідно до вимог завдання.






________________


ДОДАТОК А 
Посилання на відеозапис доповіді та текст хронологічного опису доповіді
Відеозапис доповіді на YouTube: https://youtu.be/zCjP20KIMcE
00:00 Привітання та титульний слайд із заголовком
00:15 Що таке шаблони проектування. Їх види. Класифікація шаблону "Проксі"
01:28 Суть шаблону "Проксі". Загальна інформація про шаблон
02:28 Аналогії з життя для кращого розуміння принципу роботи шаблону
03:46 Види шаблону "Проксі" за метою використання (типом завдання)
06:09 Приклад використання механізму віртуального проксі
07:18 Продовження демонстрації прикладу використання механізму віртуального проксі з демонстрацією результату виконання програмного коду
08:36 Порівняння з іншими шаблонами. Спільні властивості та різниця між ними
09:57 Підбиття підсумків з акцентом на застосування шаблону
10:56 Список використаної літератури


________________


ДОДАТОК Б 
Презентація до доповіді 


  
Рисунок Б.1 – Титульний слайд презентації 


  



Рисунок Б.2 – Що таке шаблони проектування. Класифікація
  

Рисунок Б.3 – Суть проксі. 


  

Рисунок Б.4 – Приклади з життя, аналогія з шаблоном “Проксі”








  
  
                Рисунок Б.5 – Основні види проксі


  

Рисунок Б.6 – Приклад використання шаблону у коді
________________
  

                Рисунок Б.7 – Приклад використання шаблону у коді, демонстрація результатів




  

Рисунок Б.8 – Порівняння іншими шаблонами проектування
________________
  
Рисунок Б.9 – Висновки доповіді

  Рисунок Б.10 – Список використаної для доповіді літератури




________________


ДОДАТОК В
Приклад програмного коду


1  using System;
2  
3  namespace ProxyPatternExample
4  {
5   // Спільний інтерфейс
6    public interface IImage
7    {
8        void Display();
9    }
10
11  // Реальний об'єкт, який виконує основну роботу
12  public class RealImage : IImage
13 {
14      private string _filename;
15
16      public RealImage(string filename)
17      {
18          _filename = filename;
19          LoadFromDisk();
20      }
21
22      private void LoadFromDisk()
23      {
24           Console.WriteLine($"Завантаження зображення: {_filename}");
25      }
26
27      public void Display()
28      {
29           Console.WriteLine($"Відображення зображення: {_filename}");
30      }
31  }
32
33   // Проксі, який контролює доступ до RealImage
34  public class ProxyImage : IImage
35  {
36      private RealImage _realImage;
37      private string _filename;
38
39      public ProxyImage(string filename)
40      {
41          _filename = filename;
42      }
43
44      public void Display()
45      {
46          if (_realImage == null)
47          {
48              _realImage = new RealImage(_filename);
49          }
50          _realImage.Display();
51      }
52  }
53
54  class Program
55  {
56      static void Main()
57      {
58          IImage image = new ProxyImage("photo.jpg");
59
60          // Зображення ще не завантажено
61          Console.WriteLine("Перше звернення:");
62          image.Display();
63
64          // Повторне звернення — зображення вже в кеші
65          Console.WriteLine("\nДруге звернення:");
66          image.Display();
67      }
68  }
69 }
